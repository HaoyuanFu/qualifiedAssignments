\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 2 Report}
\author{Harry(Haoyuan) Fu fuh6}
\date{\today}

\begin {document}

\maketitle

Report for Assignment2, analysis of my partner's and mine assignment result.  

\section{Testing of the Original Program}

In the testAll.py file, it used many different sets of numbers to focus on testing three modules which are CurveADT, Data and SeqServices. For the reult of testing these three modules, CurveADT has 39 stmts and has 0 miss, Data has 27 stmts and has 0 miss and SeqServices has 15 stmts and 0 miss. According to the test coverage of these three modules, it shows that these modules passed testing and have a logical output. In the description of Assignment2, it says that we do not need to do the test coverage for Load and Plot module, so the test coverage for these two modules are 0 percent. Because we do not need to execute all of codes in our modules, so the test coverage for Exceptions.py is 80 percent which has 6 misses and testAll.py has 99 percent coverage which has 2 misses.

\section{Results of Testing Partner's Code}

The test coverage for my partner's three modules are: 80 percent for CurveADT.py, 37 percent for Data.py and 93 percent for SeqServices.py. After the test coverage, terminal showed all the failures during the testing. Most failures are in Data.py and all of them are TypeError. Other than there are some AssertionError in testAll.py. I will do some explanation of my partner's result's explanation in the later part. 

\section{Discussion of Test Results}

\subsection{Problems with Original Code}
From my perspective, the total coverage for my code is 86 percent and get 100 percent in three main modules. So my test case worked well on my code. The reason of I got some misses and the coverage is not totally 100 percent is there are some commands do not need to be actually implemented and tested, so my test case may not covered all the exceptions but the main part of this program works well. 
\subsection{Problems with Partner's Code}
1. In my original Data.py, it passes all the vatiables as staticmethod but my partner didn't make them as staticmethod. As long as my test case doing Data\_init() in every test function for Data.py, it will show the TypeError again and again. \\
2. In my partner's CurveADT.py, the constructor \_\_init\_\_ didn't make self.X and self.Y as list but in my code I made them as list. When my test case trying to call the constructor it will raise a TypeError in CurveADT.py. \\
3. Because there are some TypeErrors occurred in Data.py and CurveADT.py, the test\_All raised some AsserstionError. \\
4. Above all, all the errors occurred causes the test coverage could not approach to 100 percent.
\subsection{Problems with Assignment Specification}
This assignment's specification is much different than assignment1 's specification. The most different thing is assignment 2 used MIS. Using MIS helps to improve quality and correctness of our program. But there are some problem of using the MIS which is we have to spend time to understand the requirements.\\
For example, the specification for Load module is hard to understand and also not spcific, it doesn't have any output so we couldn't find out what this module actually do by this MIS form.\\
Also during the coding process, I was confused about the definition of environment variable. The definition of environment variable should be more specific in this specification. 
\section{Answers}

\begin{enumerate}

\item What is the mathematical specification of the \texttt{SeqServices} access
  program isInBounds(X, x) if the assumption that X is ascending is removed?\\
  \\
Answer:\\
If the assumption that X is ascending is removed, which means the X is not necessarily ascending. When isInBounds(X,x) called, it will return a value between X[0] and X[-1]. Mathematically, isInBound still picks a number between X[0] and X[-1] if X is not ascending anmore. So remove the assumption of X is ascending will not effect the correctness.  

\item How would you modify \texttt{CurveADT.py} to support cubic interpolation?\\
  \\
Answer:\\
In my interpQuad function in SeqServices.py, I can simply change the interpQuad(x0, y0, x1, y1, x2, y2, x) to interpCubic(x0, y0, x1, y1, x2, y2, x3, y3, x), I need to provide three points instead of two points to do the cubic interpolation. Then I have to change the basic algorithm to cubic which is change all the **2 to **3. Then we can let interp(X, Y, o, v) in CurveADT.py to call this interpCubic funtion to support cubic interpolation. 

\item What is your critique of the CurveADT module's interface.  In particular,
  comment on whether the exported access programs provide an interface that is
  consistent, essential, general, minimal and opaque.\\
  \\
Answer:\\
In CurveADT, all the function is worked based on the assumption which is isInBounds is true. This determines if a given value is inside the range of a given sequence. Then we interpolates a linearly a curve with this assumption and then interpolates quadratically a curve with this assumption. All the function is based on the assumption which is x is a value between the sequence. If we want to pick the "edges" value as a point what behaviour should be done to this situation has to be provided. 

\item What is your critique of the Data abstract object's interface.  In
  particular, comment on whether the exported access programs provide an
  interface that is consistent, essential, general, minimal and opaque.\\
 \\
Answer:\\
The variable Z in Data has no domain, we can't get the actual size of Z out of our program. So when we excute Data.add(s,z) and Data.eval(s,z) we have to guess the value of z to make sure the value of z is fit for the program. To make Data more general and flexible it has to provide an accessor. \\
Users have no idea how to use this Data module,and generality can't predict what task would this module to be done. So we have to make it more general and flexiable by adding a del method to improve the generality. 
\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}

\def\thesection{\Alph{section}}

\section{Code for CurveADT.py}

\noindent \lstinputlisting{../src/CurveADT.py}

\newpage

\section{Code for Data.py}

\noindent \lstinputlisting{../src/Data.py}

\newpage

\section{Code for SeqServices.py}

\noindent \lstinputlisting{../src/SeqServices.py}

\newpage

\section{Code for Plot.py}

\noindent \lstinputlisting{../src/Plot.py}

\newpage

\section{Code for Load.py}

\noindent \lstinputlisting{../src/Load.py}

\newpage

\section{Code for Partner's CurveADT.py}

% Uncomment the line below when partner files have been pushed to your repo
\noindent \lstinputlisting{../partner/CurveADT.py}

\newpage

\section{Code for Partner's Data.py}

% Uncomment the line below when partner files have been pushed to your repo
\noindent \lstinputlisting{../partner/Data.py}

\newpage

\section{Code for Partner's SeqServices.py}

% Uncomment the line below when partner files have been pushed to your repo
\noindent \lstinputlisting{../partner/SeqServices.py}

\newpage

\section{Makefile}

\lstset{language=make}
\noindent \lstinputlisting{../Makefile}

\end {document}
